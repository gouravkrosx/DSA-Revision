1) sort and array using recursion
2)DP question-> https://www.youtube.com/watch?v=VT4bZV24QNo
3)Heavy weight knapsack
4) cses problemset dp questions
5) Just add all the questions from eclipse after doing all questions
6)https://www.youtube.com/watch?v=tRpkluGqINc ->Target Sum Subset

SOLUTIONS OF THESE QUESTIONS ARE EITHER ON GFG OR ON LEETCODE.
---------------------------------------DYNAMIC PROGRAMMING-----------------------------------------

1. 0-1 Knapsack 
public static int KnapsackTD(int[] wt, int[] price, int vidx, int cap, int[][] strg) {
//		if (cap < 0) {
//			return Integer.MAX_VALUE;
//		}

		if (vidx == wt.length) {
			return 0;
		}
		if (strg[vidx][cap] != 0) {
			return strg[vidx][cap];
		}
		int ans = 0;
		int in = 0;
		if (cap >= wt[vidx]) {
			in = KnapsackTD(wt, price, vidx + 1, cap - wt[vidx], strg) + price[vidx];
		}
		int ex = KnapsackTD(wt, price, vidx + 1, cap, strg);
		ans = Math.max(in, ex);

		strg[vidx][cap] = ans;
		return ans;

	}
----------------- -------------------------------------------------------------------------------
2. Matrix Chain Multiplication
public static int MCMTD(int[] matrix, int si, int ei, int[][] strg) {
		if (ei - si == 1) {
			return 0;
		}

		if (strg[si][ei] != 0) {
			return strg[si][ei];
		}
		int ans = Integer.MAX_VALUE;
		for (int k = si + 1; k <= ei - 1; k++) {
			int fp = MCMTD(matrix, si, k, strg);
			int sp = MCMTD(matrix, k, ei, strg);
			int sw = matrix[si] * matrix[k] * matrix[ei];
			int overall = fp + sp + sw;
			if (overall < ans) {
				ans = overall;
			}

		}
		strg[si][ei] = ans;
		return ans;
	}
------------------------------------------------------------------------------------------------
3. Edit Distance
    public int EditdistanceTD(String s1, String s2, int[][] strg) {

		if (s1.length() == 0 || s2.length() == 0) {
			return Math.max(s1.length(), s2.length());
		}

		if (strg[s1.length()][s2.length()] != -1) {
			return strg[s1.length()][s2.length()];
		}

		char ch1 = s1.charAt(0);
		char ch2 = s2.charAt(0);
		String ros1 = s1.substring(1);
		String ros2 = s2.substring(1);
		int ans = 0;
		if (ch1 == ch2) {
			ans = EditdistanceTD(ros1, ros2, strg);
		} else {
			int ins = EditdistanceTD(ros1, s2, strg) + 1;
			int del = EditdistanceTD(s1, ros2, strg) + 1;
			int rep = EditdistanceTD(ros1, ros2, strg) + 1;

			ans = Math.min(ins, Math.min(del, rep));
		}
		strg[s1.length()][s2.length()] = ans;
		return ans;
	}
------------------------------------------------------------------------------------------------
4. Catalan Number to find no. of Bst's
	public static int Catalannumberofbsts(int n, int[] strg) {
		if (n <= 1) {
			return 1;
		}
		if (strg[n] != 0) {
			return strg[n];
		}
		int sum = 0;
		for (int i = 1; i <= n; i++) {
			int left = Catalannumberofbsts(i - 1, strg);
			int right = Catalannumberofbsts(n - i, strg);
			int total = left * right;
			sum += total;

		}

		strg[n] = sum;
		return sum;
	}

->Catalan Number
public static void CatalanNumber(int n) {
		int dp[] = new int[n + 1];
		dp[0] = 1;
		dp[1] = 1;
		for (int i = 2; i < dp.length; i++) {
			for (int j = 0; j < i; j++) {
				dp[i] += dp[j] * dp[i - j - 1];
			}
		}
		System.out.println(dp[n]);
	}
------------------------------------------------------------------------------------------------
5. Longest Common Subsequence 
 public  int LCSTD(String s1, String s2, int[][] strg) {
		if (s1.length() == 0 || s2.length() == 0) {
			return 0;
		}

		if (strg[s1.length()][s2.length()] != -1) {
			return strg[s1.length()][s2.length()];
		}
		char ch1 = s1.charAt(0);
		char ch2 = s2.charAt(0);
		String ros1 = s1.substring(1);
		String ros2 = s2.substring(1);
		int ans = 0;
		if (ch1 == ch2) {
			ans = LCSTD(ros1, ros2, strg) + 1;
		} else {
			int fp = LCSTD(s1, ros2, strg);
			int sp = LCSTD(ros1, s2, strg);

			ans = Math.max(fp, sp);
		}
		strg[s1.length()][s2.length()] = ans;
		return ans;
	}
*)LCS Space Optimised->
public int LCsSpaceOptimised(String s1, String s2) {
		int[] strg = new int[s2.length() + 1];
		int prev = 0; //for taking ros1,ros2 in acccount because we can't get this from 1d array

		for (int i = s1.length() - 1; i >= 0; i--) {
			prev = strg[strg.length - 1];
			for (int j = strg.length - 2; j >= 0; j--) {
				int backup = strg[j];
				char ch1 = s1.charAt(i);
				char ch2 = s2.charAt(j);
				int ans = 0;
				if (ch1 == ch2) {
					ans = prev + 1;
				} else {
					int fp = strg[j + 1];
					int sp = strg[j];
					ans = Math.max(fp, sp);
				}
				prev = backup;
				strg[j] = ans;
			}
		}
		return strg[0];
	}
------------------------------------------------------------------------------------------------
6. Palindromic Partitions/cuts 
->BLog because we did some further optimization in this question  
https://leetcode.com/problems/palindrome-partitioning-ii/discuss/1267844/JAVA-or-Recursion-%2B-Memoization-or-Optimized-Matrix-Chain-Multiplication-Approach-with-Code-(MCM)

public int PalindromicpartitionscutTD(String str, int si, int ei, int[][] strg) {
		if (strg[si][ei] != -1) {
			return strg[si][ei];
		}

		if (Ispalindrome(str, si, ei)) {
			return 0;
		}

		int ans = Integer.MAX_VALUE;
		for (int k = si; k <= ei - 1; k++) {
			if (Ispalindrome(str, si, k)) {
				int min = 1 + PalindromicpartitionscutTD(str, k + 1, ei, strg);
				ans = Math.min(min, ans);
			}

		}
		strg[si][ei] = ans;
		return ans;
	}
------------------------------------------------------------------------------------------------
7. Wildcard Matching
public boolean WildcardpatternTD(String s1, String s2, int[][] strg) {
		if (s1.length() == 0 && s2.length() == 0) {
			return true;
		}
		if (s1.length() != 0 && s2.length() == 0) {
			return false;
		}

		if (s1.length() == 0 && s2.length() != 0) {
			for (int i = 0; i < s2.length(); i++) {
				if (s2.charAt(i) != '*') {
					return false;
				}
			}
			return true;

		}

		if (strg[s1.length()][s2.length()] != 0) {
			return strg[s1.length()][s2.length()] == 2 ? true : false;
		}

		char ch1 = s1.charAt(0);
		char ch2 = s2.charAt(0);
		String ros1 = s1.substring(1);
		String ros2 = s2.substring(1);

		boolean ans = false;
		if (ch1 == ch2 || ch2 == '?') {
			ans = WildcardpatternTD(ros1, ros2, strg);
		} else if (ch2 == '*') {
			boolean op1 = WildcardpatternTD(s1, ros2, strg);
			boolean op2 = WildcardpatternTD(ros1, s2, strg);
			ans = op1 || op2;
		}
		strg[s1.length()][s2.length()] = (ans) ? 2 : 1;
		return ans;
	}
------------------------------------------------------------------------------------------------
8. Board Path/Dice Combination (CSES) 
public static int boardpathTD(int curr, int end, int[] strg) {
		if (curr == end) {
			return 1;
		}
		if (curr > end) {
			return 0;
		}
		if (strg[curr] != 0) {
			return strg[curr];
		}
		int count = 0;
		for (int dice = 1; dice <= 6; dice++) {
			if (curr + dice <= end) {
				count += boardpathTD(curr + dice, end, strg);
			}
		}
		strg[curr] = count;

		return count;
	} 
------------------------------------------------------------------------------------------------
9. Coin Change/ CoinCombinationII (CSES)
->Using 2 states
public  long CoinCombinationII(int[] coin, int val, int n) {
		long[][] dp = new long[n + 1][val + 1];

		for (int i = 1; i <= n; i++) {
			for (int sum = 0; sum <= val; sum++) {
				if (sum == 0) {
					dp[i][sum] = 1;
				} else {
					long op1 = (coin[i-1] > sum) ? 0 : dp[i][sum - coin[i-1]];
					long op2 = (i == 1) ? 0 : dp[i - 1][sum];
					dp[i][sum] = (op1 + op2);
				}
			}
		}
		return dp[n][val];
	}
Using One state only->
 public int CoinCombinationII(int[] coin, int val, int n) {
		int[] dp = new int[val + 1];
		dp[0] = 1; // if no sum then we can leave this and this could be a way 
		for (int i = 0; i < n; i++) {
			for (int j = coin[i]; j < dp.length; j++) {
				dp[j] += dp[j - coin[i]];

			}
		}
		return dp[val];
	}

CoinCombinationI (Permutation) (CSES) 
public static long CoinCombinationI(int[] coin, int val, int n) {
		long[] dp = new long[val + 1];
		dp[0] = 1; // if no sum then we can leave and this could be a way
		for (int sum = 1; sum <= val; sum++) {
			for (int coin_value : coin) {
				if (coin_value <= sum)
					dp[sum] = (dp[sum] + dp[sum - coin_value]) % MOD;
			}
		}
		return dp[val];
	}
------------------------------------------------------------------------------------------------
10. Minimizing Coins/ Coin change on leetcode
 public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        int[]dp=new int[amount+1];
        
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for(int i=0;i<=amount;i++){
            for(int j=0;j<coins.length;j++){
                if(coins[j]<=i){
                    dp[i]=Math.min(dp[i],1+dp[i-coins[j]]);
                }else
                    break;
            }
        }
        return (dp[amount]>amount)?-1:dp[amount];        
    }
------------------------------------------------------------------------------------------------
11. Subset Sum Problem/ Partition Equal Subset Sum
public boolean SubsetSum(int nums[], int vidx, int sum, int total,HashMap<String,Boolean>state) {
		String current=vidx+""+sum;
        if (state.containsKey(current)) {
			return state.get(current);
		}
		if (total == 2 * sum) {
			return true;
		}

		if (sum > total || vidx >= nums.length)
			return false;

		boolean ans=SubsetSum(nums,vidx+1,sum+nums[vidx],total,state)||
            SubsetSum(nums,vidx+1,sum,total,state);

		state.put(current,ans);
		return ans;
	}

------------------------------------------------------------------------------------------------
12. Target Sum Subset
------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------