1) sort and array using recursion
2)DP question-> https://www.youtube.com/watch?v=VT4bZV24QNo
3)Heavy weight knapsack
4) cses problemset dp questions
5) Just add all the questions from eclipse after doing all questions
6)https://www.youtube.com/watch?v=tRpkluGqINc ->Target Sum Subset

SOLUTIONS OF THESE QUESTIONS ARE EITHER ON GFG OR ON LEETCODE.
---------------------------------------DYNAMIC PROGRAMMING-----------------------------------------

1. 0-1 Knapsack 
public static int KnapsackTD(int[] wt, int[] price, int vidx, int cap, int[][] strg) {
//		if (cap < 0) {
//			return Integer.MAX_VALUE;
//		}

		if (vidx == wt.length) {
			return 0;
		}
		if (strg[vidx][cap] != 0) {
			return strg[vidx][cap];
		}
		int ans = 0;
		int in = 0;
		if (cap >= wt[vidx]) {
			in = KnapsackTD(wt, price, vidx + 1, cap - wt[vidx], strg) + price[vidx];
		}
		int ex = KnapsackTD(wt, price, vidx + 1, cap, strg);
		ans = Math.max(in, ex);

		strg[vidx][cap] = ans;
		return ans;

	}
->Bottom Up Approach->https://www.youtube.com/watch?v=bUSaenttI24&list=WL&index=57&t=21s

 public static int KnapsackBU(int[]wt,int[]val,int n,int cap){
        int[][]dp=new int[n+1][cap+1];
        
        for(int i=1;i<=n;i++){
            for(int j=1;j<=cap;j++){
                if(j>=wt[i-1]) //player can bat or weight can be added.
                {   int rCap=j-wt[i-1];
                    if(dp[i-1][rCap]+val[i-1]>dp[i-1][j]){
                       dp[i][j]=dp[i-1][rCap]+val[i-1];  //took i-1 in val array also bcz of the storage, draw matrix to know
                    }else{
                       dp[i][j]=dp[i-1][j]; 
                    }
                    
                }else{
                    dp[i][j]=dp[i-1][j]; //player can't bat or weight can't be added
                }
            }
        }
        return dp[n][cap];
    }

----------------- -------------------------------------------------------------------------------
2. Matrix Chain Multiplication
public static int MCMTD(int[] matrix, int si, int ei, int[][] strg) {
		if (ei - si == 1) {
			return 0;
		}

		if (strg[si][ei] != 0) {
			return strg[si][ei];
		}
		int ans = Integer.MAX_VALUE;
		for (int k = si + 1; k <= ei - 1; k++) {
			int fp = MCMTD(matrix, si, k, strg);
			int sp = MCMTD(matrix, k, ei, strg);
			int sw = matrix[si] * matrix[k] * matrix[ei];
			int overall = fp + sp + sw;
			if (overall < ans) {
				ans = overall;
			}

		}
		strg[si][ei] = ans;
		return ans;
	}
------------------------------------------------------------------------------------------------
3. Edit Distance
    public int EditdistanceTD(String s1, String s2, int[][] strg) {

		if (s1.length() == 0 || s2.length() == 0) {
			return Math.max(s1.length(), s2.length());
		}

		if (strg[s1.length()][s2.length()] != -1) {
			return strg[s1.length()][s2.length()];
		}

		char ch1 = s1.charAt(0);
		char ch2 = s2.charAt(0);
		String ros1 = s1.substring(1);
		String ros2 = s2.substring(1);
		int ans = 0;
		if (ch1 == ch2) {
			ans = EditdistanceTD(ros1, ros2, strg);
		} else {
			int ins = EditdistanceTD(ros1, s2, strg) + 1;
			int del = EditdistanceTD(s1, ros2, strg) + 1;
			int rep = EditdistanceTD(ros1, ros2, strg) + 1;

			ans = Math.min(ins, Math.min(del, rep));
		}
		strg[s1.length()][s2.length()] = ans;
		return ans;
	}
------------------------------------------------------------------------------------------------
4. Catalan Number to find no. of Bst's
	public static int Catalannumberofbsts(int n, int[] strg) {
		if (n <= 1) {
			return 1;
		}
		if (strg[n] != 0) {
			return strg[n];
		}
		int sum = 0;
		for (int i = 1; i <= n; i++) {
			int left = Catalannumberofbsts(i - 1, strg);
			int right = Catalannumberofbsts(n - i, strg);
			int total = left * right;
			sum += total;

		}

		strg[n] = sum;
		return sum;
	}

->Catalan Number
public static void CatalanNumber(int n) {
		int dp[] = new int[n + 1];
		dp[0] = 1;
		dp[1] = 1;
		for (int i = 2; i < dp.length; i++) {
			for (int j = 0; j < i; j++) {
				dp[i] += dp[j] * dp[i - j - 1];
			}
		}
		System.out.println(dp[n]);
	}
------------------------------------------------------------------------------------------------
5. Longest Common Subsequence 
 public  int LCSTD(String s1, String s2, int[][] strg) {
		if (s1.length() == 0 || s2.length() == 0) {
			return 0;
		}

		if (strg[s1.length()][s2.length()] != -1) {
			return strg[s1.length()][s2.length()];
		}
		char ch1 = s1.charAt(0);
		char ch2 = s2.charAt(0);
		String ros1 = s1.substring(1);
		String ros2 = s2.substring(1);
		int ans = 0;
		if (ch1 == ch2) {
			ans = LCSTD(ros1, ros2, strg) + 1;
		} else {
			int fp = LCSTD(s1, ros2, strg);
			int sp = LCSTD(ros1, s2, strg);

			ans = Math.max(fp, sp);
		}
		strg[s1.length()][s2.length()] = ans;
		return ans;
	}
*)LCS Space Optimised->
public int LCsSpaceOptimised(String s1, String s2) {
		int[] strg = new int[s2.length() + 1];
		int prev = 0; //for taking ros1,ros2 in acccount because we can't get this from 1d array

		for (int i = s1.length() - 1; i >= 0; i--) {
			prev = strg[strg.length - 1];
			for (int j = strg.length - 2; j >= 0; j--) {
				int backup = strg[j];
				char ch1 = s1.charAt(i);
				char ch2 = s2.charAt(j);
				int ans = 0;
				if (ch1 == ch2) {
					ans = prev + 1;
				} else {
					int fp = strg[j + 1];
					int sp = strg[j];
					ans = Math.max(fp, sp);
				}
				prev = backup;
				strg[j] = ans;
			}
		}
		return strg[0];
	}
------------------------------------------------------------------------------------------------
6. Palindromic Partitions/cuts 
->BLog because we did some further optimization in this question  
https://leetcode.com/problems/palindrome-partitioning-ii/discuss/1267844/JAVA-or-Recursion-%2B-Memoization-or-Optimized-Matrix-Chain-Multiplication-Approach-with-Code-(MCM)

public int PalindromicpartitionscutTD(String str, int si, int ei, int[][] strg) {
		if (strg[si][ei] != -1) {
			return strg[si][ei];
		}

		if (Ispalindrome(str, si, ei)) {
			return 0;
		}

		int ans = Integer.MAX_VALUE;
		for (int k = si; k <= ei - 1; k++) {
			if (Ispalindrome(str, si, k)) {
				int min = 1 + PalindromicpartitionscutTD(str, k + 1, ei, strg);
				ans = Math.min(min, ans);
			}

		}
		strg[si][ei] = ans;
		return ans;
	}
------------------------------------------------------------------------------------------------
7. Wildcard Matching
public boolean WildcardpatternTD(String s1, String s2, int[][] strg) {
		if (s1.length() == 0 && s2.length() == 0) {
			return true;
		}
		if (s1.length() != 0 && s2.length() == 0) {
			return false;
		}

		if (s1.length() == 0 && s2.length() != 0) {
			for (int i = 0; i < s2.length(); i++) {
				if (s2.charAt(i) != '*') {
					return false;
				}
			}
			return true;

		}

		if (strg[s1.length()][s2.length()] != 0) {
			return strg[s1.length()][s2.length()] == 2 ? true : false;
		}

		char ch1 = s1.charAt(0);
		char ch2 = s2.charAt(0);
		String ros1 = s1.substring(1);
		String ros2 = s2.substring(1);

		boolean ans = false;
		if (ch1 == ch2 || ch2 == '?') {
			ans = WildcardpatternTD(ros1, ros2, strg);
		} else if (ch2 == '*') {
			boolean op1 = WildcardpatternTD(s1, ros2, strg);
			boolean op2 = WildcardpatternTD(ros1, s2, strg);
			ans = op1 || op2;
		}
		strg[s1.length()][s2.length()] = (ans) ? 2 : 1;
		return ans;
	}
------------------------------------------------------------------------------------------------
8. Board Path/Dice Combination (CSES) 
public static int boardpathTD(int curr, int end, int[] strg) {
		if (curr == end) {
			return 1;
		}
		if (curr > end) {
			return 0;
		}
		if (strg[curr] != 0) {
			return strg[curr];
		}
		int count = 0;
		for (int dice = 1; dice <= 6; dice++) {
			if (curr + dice <= end) {
				count += boardpathTD(curr + dice, end, strg);
			}
		}
		strg[curr] = count;

		return count;
	} 
------------------------------------------------------------------------------------------------
9. Coin Change/ CoinCombinationII (CSES)
->Using 2 states
public  long CoinCombinationII(int[] coin, int val, int n) {
		long[][] dp = new long[n + 1][val + 1];

		for (int i = 1; i <= n; i++) {
			for (int sum = 0; sum <= val; sum++) {
				if (sum == 0) {
					dp[i][sum] = 1;
				} else {
					long op1 = (coin[i-1] > sum) ? 0 : dp[i][sum - coin[i-1]];
					long op2 = (i == 1) ? 0 : dp[i - 1][sum];
					dp[i][sum] = (op1 + op2);
				}
			}
		}
		return dp[n][val];
	}
Using One state only->
 public int CoinCombinationII(int[] coin, int val, int n) {
		int[] dp = new int[val + 1];
		dp[0] = 1; // if no sum then we can leave this and this could be a way 
		for (int i = 0; i < n; i++) {
			for (int j = coin[i]; j < dp.length; j++) {
				dp[j] += dp[j - coin[i]];

			}
		}
		return dp[val];
	}

CoinCombinationI (Permutation) (CSES) 
public static long CoinCombinationI(int[] coin, int val, int n) {
		long[] dp = new long[val + 1];
		dp[0] = 1; // if no sum then we can leave and this could be a way
		for (int sum = 1; sum <= val; sum++) {
			for (int coin_value : coin) {
				if (coin_value <= sum)
					dp[sum] = (dp[sum] + dp[sum - coin_value]) % MOD;
			}
		}
		return dp[val];
	}
------------------------------------------------------------------------------------------------
10. Minimizing Coins/ Coin change on leetcode
 public int coinChange(int[] coins, int amount) {
        Arrays.sort(coins);
        int[]dp=new int[amount+1];
        
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for(int i=0;i<=amount;i++){
            for(int j=0;j<coins.length;j++){
                if(coins[j]<=i){
                    dp[i]=Math.min(dp[i],1+dp[i-coins[j]]);
                }else
                    break;
            }
        }
        return (dp[amount]>amount)?-1:dp[amount];        
    }
------------------------------------------------------------------------------------------------
11. Subset Sum Problem/ Partition Equal Subset Sum
public boolean SubsetSum(int nums[], int vidx, int sum, int total,HashMap<String,Boolean>state) {
		String current=vidx+""+sum;
        if (state.containsKey(current)) {
			return state.get(current);
		}
		if (total == 2 * sum) {
			return true;
		}

		if (sum > total || vidx >= nums.length)
			return false;

		boolean ans=SubsetSum(nums,vidx+1,sum+nums[vidx],total,state)||
            SubsetSum(nums,vidx+1,sum,total,state);

		state.put(current,ans);
		return ans;
	}

------------------------------------------------------------------------------------------------
12. Target Sum Subset ->(Kind of 0-1 Knapsack Problem)
https://www.pepcoding.com/resources/online-java-foundation/dynamic-programming-and-greedy/target-sum-subsets-dp-official/ojquestion

 public static boolean TargetSumSubsets(int[]arr,int n,int tar){
      boolean[][]dp=new boolean[n+1][tar+1];
      dp[0][0]=true; //because empty set can be make sum 0 only.
      for(int i=1;i<=n;i++){
        for(int j=0;j<=tar;j++){
            if(j==0){
                dp[i][j]=true;
                continue;
            }
            if(j<arr[i-1]){
                dp[i][j]=dp[i-1][j];
            }else{
                boolean op1=dp[i-1][j];
                boolean op2=dp[i-1][j-arr[i-1]];
                dp[i][j]=op1||op2;
            }
        }
      }
      return dp[n][tar];
  }
------------------------------------------------------------------------------------------------
13. Friends Pairing Problem
 public static long FriendsPairing(int n) {
		if (n == 0)
			return 0;
		if (n == 1)
			return 1;
		if (n == 2)
			return 2;

		long dp[] = new long[n + 1];

		int M = 1000000007;

		dp[1] = 1;
		dp[2] = 2;

		for (int i = 3; i < dp.length; i++) {
			dp[i] = (dp[i - 1] + ((i - 1) * dp[i - 2]) % M) % M;
		}
		
		return dp[n];
	}
------------------------------------------------------------------------------------------------
14. Binomial Coefficient Problem (nCr)
Formula Used->   C(n, r) = C(n-1, r-1) + C(n-1, r)
 C(n, 0) = C(n, n) = 1
 public static int nCr(int n, int r) {
		int C[][] = new int[n + 2][r + 2];

		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= Math.min(i, r); j++) {
				if (j == 0 || j == i)
					C[i][j] = 1;
				else
					C[i][j] = (C[i - 1][j] % MOD + (C[i - 1][j - 1]) % MOD) % MOD;

			}
		}
		return C[n][r];
	}


------------------------------------------------------------------------------------------------
15. Permutation Coefficient Problem (nPr)
Formula Used->P(n, k) = P(n-1, k) + k* P(n-1, k-1)
P(n,0)=1;

static int permutationCoeff(int n,
                                int k)
    {
        int P[][] = new int[n + 2][k + 2];
     
        // Calculate value of Permutation
        // Coefficient in bottom up manner
        for (int i = 0; i <= n; i++)
        {
            for (int j = 0;
                j <= Math.min(i, k);
                j++)
            {
                // Base Cases
                if (j == 0)
                    P[i][j] = 1;
     
                // Calculate value using previosly
                // stored values
                else
                    P[i][j] = P[i - 1][j] +
                            (j * P[i - 1][j - 1]);
     
                // This step is important
                // as P(i,j)=0 for j>i
                P[i][j + 1] = 0;
            }
        }
        return P[n][k];
    }
------------------------------------------------------------------------------------------------
16. Grid Paths (CSES)
 public static int GridPaths(int[][] grid, int n) {
		int[][] strg = new int[n + 1][n + 1];

		for (int row = n; row >= 1; row--) {
			for (int col = n; col >= 1; col--) {
				if (grid[row - 1][col - 1] == 1) {
					strg[row][col] = 0;
					continue;
				}
				if (row == n && col == n) {
					strg[row][col] = 1;
				} else {
					int op1 = (col == n) ? 0 : strg[row][col + 1];
					int op2 = (row == n) ? 0 : strg[row + 1][col];
					strg[row][col] = (op1 + op2) % MOD;
				}
			}
		}
		return strg[1][1];
	}
------------------------------------------------------------------------------------------------
17. Removing Digits (CSES)
	private static int RemovingDigits(int n) {
		int[] dp = new int[n + 1];
		for (int i = 1; i <= n; i++) {
			char[] arr = new String("" + i).toCharArray();
			int res = Integer.MAX_VALUE;
			for (int j = 0; j < arr.length; j++) {
				if (arr[j] != '0')
					res = Math.min(dp[i - (arr[j] - '0')] + 1, res);
			}
			dp[i] = res;
		}
		return dp[n];
	}
------------------------------------------------------------------------------------------------
18. Longest Common Subsequence 3D (with 3 Strings)
public static int LCS3(String s1, String s2, String s3, int[][][] strg) {
		if (s1.length() == 0 || s2.length() == 0 || s3.length() == 0) {
			return 0;
		}

		if (strg[s1.length()][s2.length()][s3.length()] != -1) {
			return strg[s1.length()][s2.length()][s3.length()];
		}
		char ch1 = s1.charAt(0);
		char ch2 = s2.charAt(0);
		char ch3 = s3.charAt(0);
		String ros1 = s1.substring(1);
		String ros2 = s2.substring(1);
		String ros3 = s3.substring(1);
		int ans = 0;
		if (ch1 == ch2 && ch2 == ch3) {
			ans = LCS3(ros1, ros2, ros3, strg) + 1;
		} else {
			int options[] = new int[6];
			options[0] = LCS3(s1, ros2, ros3, strg);
			options[1] = LCS3(ros1, s2, ros3, strg);
			options[2] = LCS3(ros1, ros2, s3, strg);
			options[3] = LCS3(s1, s2, ros3, strg);
			options[4] = LCS3(s1, ros2, s3, strg);
			options[5] = LCS3(ros1, s2, s3, strg);
			ans = 0;
			for (int val : options)
				ans = Math.max(ans, val);

		}
		strg[s1.length()][s2.length()][s3.length()] = ans;
		return ans;
	}
------------------------------------------------------------------------------------------------
19. 
------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------