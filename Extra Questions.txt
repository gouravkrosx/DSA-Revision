              			Some Extra Questions

------------------------------------------------------------------------------------
1. Tower of Hanoi ->https://www.youtube.com/watch?v=QDBrZFROuA0
-> Make the recursion Tree and do the dry run , and do inorder traversal 
public static void toh(int n, int t1id, int t2id, int t3id){
        if(n==0){
            return;
        }
        //(*) ->Means following all instructions of tower of hanoi
        toh(n-1,t1id,t3id,t2id); //will print the instructions to move n-1 disks from t1 to t3 using t2(*)
        System.out.println(n+"["+t1id+" -> "+t2id+"]");
        toh(n-1,t3id,t2id,t1id);
    }
-------------------------------------------------------------------------------------
2. Do All variations of buy and sell stock

-> https://www.youtube.com/watch?v=MyqDgMy-Kew

a) Buy & Sell Stock -> part 1 and 2 in dp and arrays

b) Buy and sell stock with transaction fee (LeetCode 714)
->  public int maxProfit(int[] prices, int fee) {
        if(prices.length==0){
            return 0;
        }
        // at any ith day we have 2 options
        // if you don't own a stock-> 2 options either buy or not
        // if you own a stock -> 2 options either sell or not
        
        // as soon as i buy ->  - (prices[i]+fee);
        // as soon as i sell -> + prices[i] 
    
        int[][]dp=new int[prices.length][2];
        for(int[]dpp:dp){
            Arrays.fill(dpp,-1);
        }
        
        //since initally i don't own a stock so passing 0 for owning means not owning
        return BuyNSellStockWithFee(0,prices,fee,0,dp);
    }
    public int BuyNSellStockWithFee(int idx, int[]prices,int fee,int own,int[][]dp){
        if(idx==prices.length)return 0;
        
        if(dp[idx][own]!=-1){
            return dp[idx][own];
        }
        
        if(own==1){
            int op1 = prices[idx]+BuyNSellStockWithFee(idx+1,prices,fee,0,dp); //sell
            int op2 = BuyNSellStockWithFee(idx+1,prices,fee,1,dp); //not sell
            return dp[idx][own]=Math.max(op1,op2);
        }else{
            int op1 = -(prices[idx]+fee)+BuyNSellStockWithFee(idx+1,prices,fee,1,dp); //buy
            int op2 = BuyNSellStockWithFee(idx+1,prices,fee,0,dp); //not buy
            return dp[idx][own]=Math.max(op1,op2);
        }
    }

c) Buy and Sell Stock with Cooldown ( LeetCode 309)

(for Buy and sell stock 3 & 4 you can refer kartik arora solution which is very intuitive as well)

d) Buy and Sell Stock III (in dp section)

e) Buy and Sell Stock IV (k transactions allowed) (in dp section)
->
class Solution {
    public int maxProfit(int[] prices) {
        //intuition : 
        // we will have 3 states i) index ii) own or now own iii) cooldown or not cooldown
        // cooldown only give problem while buying not with selling.
        
        // else the explaination remains same as buy and sell stock with transaction fee.
        
        int[][][]dp=new int[prices.length][2][2];
        
        for(int [][]dpp:dp){
            for(int[]dppp:dpp){
                Arrays.fill(dppp,-1);
            }
        }
        //since intially we don't have the cooldown
        return BuyNSellStockCooldown(0,0,0,prices,dp);
    }
    
    public int BuyNSellStockCooldown(int idx, int own ,int cooldown,int[]prices,int[][][]dp){
        if(idx==prices.length)return 0;
        
        
        if(dp[idx][own][cooldown]!=-1){
            return dp[idx][own][cooldown];
        }
        
        if(own==0){
            int op1 = (cooldown==1)?0: -(prices[idx]) + BuyNSellStockCooldown(idx+1,1,0,prices,dp);
            int op2 = BuyNSellStockCooldown(idx+1,0,0,prices,dp);
            return dp[idx][own][cooldown]=Math.max(op1,op2);
        }else{
            int op1 = prices[idx] + BuyNSellStockCooldown(idx+1,0,1,prices,dp); //as soon as i sell there will be cooldown.
            int op2= BuyNSellStockCooldown(idx+1,1,0,prices,dp);
            return dp[idx][own][cooldown]=Math.max(op1,op2);
        }
    }
}
-------------------------------------------------------------------------------------
3. Permutations (leetcode 46)
->Time complexity->(n!*n)
->Space complexity->(2n)

Using extra space->
 public void solve( List<List<Integer>>ans,List<Integer>ds,boolean[]freq,int[]nums){
        if(ds.size()==nums.length)
        {
            ans.add(new ArrayList<>(ds));
            return;
        }
        
        for(int i=0;i<nums.length;i++){
            if(!freq[i]){
                freq[i]=true;
                ds.add(nums[i]);
                solve(ans,ds,freq,nums);
                ds.remove(ds.size()-1);
                freq[i]=false;
            }
        }
    }
Space optimised->
 public void solve(List<List<Integer>>ans,int idx,int[]nums){
    
        if(idx==nums.length){
            //copy the altered array.
            List<Integer>ds=new ArrayList<>();
            for(int i=0;i<nums.length;i++){
                ds.add(nums[i]);
            }
            ans.add(new ArrayList<>(ds));
            return;
        }
        //swap every index with every other ahead index
        for(int i=idx;i<nums.length;i++){
            swap(i,idx,nums);
            solve(ans,idx+1,nums);
            swap(i,idx,nums);
        }    
    }


-------------------------------------------------------------------------------------
4. Subarray Product less than K (leetcode 713)
-> //for every iteration,we try to get the longest subarray with product < k ending with nums[j]; 
 public int numSubarrayProductLessThanK(int[] nums, int k) {
        long pro=1l;
        int ans=0;

        int i=0,j=0;
        
        while(j<nums.length ){
            pro = pro * nums[j];
            
            while(i<=j && pro>=k){
                pro/=nums[i];
                i++;
            }
            ans+=(j-i+1);  // dry run you will get the flow that how it is calculating 
            j++;
        }
        return ans;
    }


-> Similar approach problem -> Number of Smooth Descent Periods of a Stock (Leetcode 2110)
-------------------------------------------------------------------------------------
5. Contiguous Array ( Leetcode 525 )
M1)
 public int findMaxLength(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        int max = 0;
        int zero = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) zero++;
            else zero--;
            if (zero == 0) max = i + 1;
            if (!map.containsKey(zero)) map.put(zero, i);
            else max = Math.max(max, i - map.get(zero));
        }
        return max;
    }

M2)
-> Just add 1 in case of 0 and -1 in case of 1 and find the largest subarray with sum 0
-> i mean the below solution.
-------------------------------------------------------------------------------------
6. Largest Subarray with sum 0 
 public static int LargestSubarrayWithSum0(int[]arr,int n){
        HashMap<Integer,Integer>map=new HashMap<>();
        int max=0;
        int sum=0;
        
        for(int i=0;i<arr.length;i++){
            sum+=arr[i];
            if(sum==0){
                max=i+1;
            }else{
                if(map.get(sum)!=null){
                    max=Math.max(max,i-map.get(sum));
                }else{
                    map.put(sum,i);
                }
            }
        }
        return max;
    }

-------------------------------------------------------------------------------------
7. largest Subarray with sum no larger than k

private int maxSumSubArray(int[] a , int k){

    int max = Integer.MIN_VALUE;
    int preSum = 0;
    TreeSet<Integer> ts = new TreeSet();
    ts.add(0);

    for(int i=0;i<a.length;i++){
        preSum += a[i];
        Integer gap = ts.ceiling(preSum - k);
        if(gap != null) max = Math.max(max, preSum - gap);
        ts.add(preSum);
    }
    return max;
}

# Longest subarray with sum k
->
static int lenOfLongSubarr(int[] arr, int n, int k)
      {
             // HashMap to store (sum, index) tuples
             HashMap<Integer, Integer> map = new HashMap<>();
             int sum = 0, maxLen = 0;
 
             // traverse the given array
             for (int i = 0; i < n; i++) {
                 
                  // accumulate sum
                  sum += arr[i];
                 
                  // when subarray starts from index '0'
                  if (sum == k)
                      maxLen = i + 1;
 
                  // make an entry for 'sum' if it is
                  // not present in 'map'
                  if (!map.containsKey(sum)) {
                      map.put(sum, i);
                  }
 
                  // check if 'sum-k' is present in 'map'
                  // or not
                  if (map.containsKey(sum - k)) {
                       
                      // update maxLength
                      if (maxLen < (i - map.get(sum - k)))
                          maxLen = i - map.get(sum - k);
                  }
             }
              
             return maxLen;            
      }
-------------------------------------------------------------------------------------
8. Subarray Sum Equals K (pepcoding)
 public int subarraySum(int[] nums, int k) {
        int sum = 0, result = 0;
        Map<Integer, Integer> preSum = new HashMap<>();
        preSum.put(0, 1);
        
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (preSum.containsKey(sum - k)) {
                result += preSum.get(sum - k);
            }
            preSum.put(sum, preSum.getOrDefault(sum, 0) + 1);
        }
        
        return result;
    }
Binary Subarrays with Sum (Leetcode 930)
->  public int numSubarraysWithSum(int[] nums, int k) {

 // atMostK(nums,k)<- this will give subarray sum <=k | atMostK(nums,k-1) <= this will give subarray sum <=k-1       // the diff atMostK(nums,k) - atmostK(nums,k-1) <- this will give subarray sum exactly  == k.

        return SubarraySumAtMostK(nums,k) - SubarraySumAtMostK(nums,k-1);     
     }
    public int SubarraySumAtMostK(int[]nums,int k){
        int sum=0;
        int i=0;
        int j=0;
        int ans=0;
        
        while(j<nums.length){
            sum+=nums[j];
            while(i<=j && sum>k){
                sum-=nums[i++];
            }
            ans+=(j-i+1);
            j++;
        }
        return ans;
    }
-------------------------------------------------------------------------------------
9. Word Break (pepcoding)->https://www.youtube.com/watch?v=2NaaM_z_Jig

-------------------------------------------------------------------------------------
10. Minimum Size Subarray Sum (Leetcode 209)
-------------------------------------------------------------------------------------
11. Predict the winner
-------------------------------------------------------------------------------------
12. Frog Jump (LeetCode 403)

 public boolean canCross(int[] stones) {
        
        int n = stones.length;
        
        HashMap<Integer,HashSet<Integer>>map = new HashMap<>();
        
        
        for(int i=0;i<n;i++){
            map.put(stones[i],new HashSet<>());
        }
        //since from 0 we can take 1 jump only
        map.get(stones[0]).add(1);
        
        for(int i=0;i<n;i++){
            int currStone = stones[i];
            
            HashSet<Integer> jumps = map.get(currStone);
            
            for(int jump: jumps){
                int pos = currStone + jump;
                
                if(pos == stones[n-1])return true;
                
                if(map.containsKey(pos)){
                    if(jump-1>0)map.get(pos).add(jump-1);
                    map.get(pos).add(jump);
                    map.get(pos).add(jump+1);
                }
                
            }          
        }
        return false;
    }
-------------------------------------------------------------------------------------
13. Longest Arithmetic Subsequence of Given Difference (Leetcode 1218)
-------------------------------------------------------------------------------------
14. Longest Consecutive Sequence (Leetcode 28)
-------------------------------------------------------------------------------------
15. All Paths From Source to Target (Leetcode 797)
-------------------------------------------------------------------------------------
16. Path In Zigzag Labelled Binary Tree (Leetcode 1104.)
-------------------------------------------------------------------------------------
17. Validate Binary Tree Nodes (Leetcode 1361)
-------------------------------------------------------------------------------------
18. Biggest cycle in Directed Graph.
-------------------------------------------------------------------------------------
19. Ford-Fulkerson Algorithm for Maximum Flow Problem
	
-------------------------------------------------------------------------------------
20. Longest path in an undirected tree.
-> Apply 2 Bfs two times 
1. choose any node apply bfs to find the longest distance let this node be y.
2. Now from y apply bfs to find the longest path. which is the diamter of the tree.
-------------------------------------------------------------------------------------
21. Maximum Binary Tree (Leetcode-654)
-------------------------------------------------------------------------------------
22. Cycle sort
-------------------------------------------------------------------------------------
23. Cherry Pickup (Leetcode 741)

// we are starting both journies form (0,0) itself and not like one from 0,0 and than return journey from (n-1,n-1)
    // and this is because the possible path combination from (0,0) to (n-1,n-1) is same as (n-1,n-1) to (0,0) even if there
    // are thorns (hurdles)


public int cherryPickup(int[][] grid) {
        int[][][] dp = new int[grid.length][grid.length][grid.length];

        return Math.max(0, helper(grid, dp, 0, 0, 0));  // return 0 if there is no path from 0,0 to n-1,n-1
    }

    // Instead of going once from 0,0 to n-1,n-1 and then back, we simply go twice from 0,0 to n-1,n-1 because every path from n-1,n-1 to 0,0 can be interpreted as a path from 0,0 to n-1,n-1
    // Note that the one person can never cross the past path of the other person (they can only meet at the same position) so we don't need to worry about one person picking up an already picked up cherry from the past
    // What does a state represent? dp[r1][c1][c2] represents the max number of cherries that can be collected by 2 people going from r1,c1 and r2,c2 to n-1,n-1
    // Transitions between states? we collect cherries on current positions of the two people (r1,c1 and r2,c2), then we go through all possible next states and choose the best one (max number of cherries) as the next state (we do this by adding the number of cherries of the best next state to the number of cherries we picked up on the current two positions of the people). In the end, the state dp[0][0][0] will contain the max number of cherries that can be picked up by going from 0,0 to n-1,n-1 and back.

    private int helper(int[][] grid, int[][][] dp, int r1, int c1, int  c2) {

        // we can deduce r2 because r1 + c1 == r2 + c2, since with each move either r or c of a person gets incremented by exactly one (Manhattan distance to origin stays equal)
        // this way we reduce the 4D dp problem to a 3D one (we save space by reducing the number of things we store in a state)
        int r2 = r1 + c1 - c2;

        // check if current state is out of bounds or on thorns
        if (r1 >= grid.length || c1 >= grid.length || r2 >= grid.length || c2 >= grid.length || grid[r1][c1] == -1 || grid[r2][c2] == -1) {
            return Integer.MIN_VALUE;   // current state should not be included in the solution
        }

        // check if we have already computed a solution for this state
        if (dp[r1][c1][c2] != 0) return dp[r1][c1][c2];

        // check if we reached the end state (note that if r1,c1 reached the end, this implies that r2,c2 also reached the end)
        if (r1 == grid.length - 1 && c1 == grid.length - 1) {
            return grid[r1][c1];
        }

        // compute and return answer for current state
        int result = grid[r1][c1];

        // in case the second person is on the same position, don't pick up the same cherry twice. Note that r1 == r2 <--> c1 == c2 (eg. they can't be on the same row without also being on the same column) 
        if (r1 != r2) {
            result += grid[r2][c2];
        }

        // pick best possible next state
        int bestNextState = Math.max(helper(grid, dp, r1 + 1, c1, c2),  // down, down 
                                    helper(grid, dp, r1, c1 + 1, c2 + 1));  // right, right    
        bestNextState = Math.max(bestNextState, helper(grid, dp, r1 + 1, c1, c2 + 1));   // down, right
        bestNextState = Math.max(bestNextState, helper(grid, dp, r1, c1 + 1, c2));   // right, down

        result += bestNextState;
        dp[r1][c1][c2] = result;    // store current state such that it can be re-used

        return result;
    }
-------------------------------------------------------------------------------------
24. Split Array Largest Sum (Leetcode 410) Premium**
-------------------------------------------------------------------------------------
25. Divide Chocolate (Leetcode 1231) Premium**
-------------------------------------------------------------------------------------
26. Combinations (LeetCode 77)
->  public static List<List<Integer>> combine(int n, int k) {
		List<List<Integer>> combs = new ArrayList<List<Integer>>();
		combine(combs, new ArrayList<Integer>(), 1, n, k);
		return combs;
	}
	public static void combine(List<List<Integer>> combs, List<Integer> comb, int start, int n, int k) {
		if(k==0) {
			combs.add(new ArrayList<Integer>(comb));
			return;
		}
		for(int i=start;i<=n;i++) {
			comb.add(i);
			combine(combs, comb, i+1, n, k-1);
			comb.remove(comb.size()-1);
		}
	}
-------------------------------------------------------------------------------------
27. House Robber 3 -> https://leetcode.com/problems/house-robber-iii/discuss/79330/Step-by-step-tackling-of-the-problem

->  we are just checking whether we would rob root or not.

public int rob(TreeNode root) {
    return robSub(root, new HashMap<>());
}

private int robSub(TreeNode root, Map<TreeNode, Integer> map) {
    if (root == null) return 0;
    if (map.containsKey(root)) return map.get(root);
    
    int val = 0;
    
    if (root.left != null) {
        val += robSub(root.left.left, map) + robSub(root.left.right, map);
    }
    
    if (root.right != null) {
        val += robSub(root.right.left, map) + robSub(root.right.right, map);
    }
    
    val = Math.max(val + root.val, robSub(root.left, map) + robSub(root.right, map));
    map.put(root, val);
    
    return val;
}

-> More optimised
public int rob(TreeNode root) {
    int[] res = robSub(root);
    return Math.max(res[0], res[1]);
}

private int[] robSub(TreeNode root) {
    if (root == null) return new int[2];
    
    int[] left = robSub(root.left);
    int[] right = robSub(root.right);
    int[] res = new int[2];

    res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    res[1] = root.val + left[0] + right[0];
    
    return res;
}
-------------------------------------------------------------------------------------
28. Permutation in String (Leetcode : 567)

-> Sliding window approach that can be used in various other questions also.

public boolean checkInclusion(String s1, String s2) {
        
        if(s1.length()>s2.length()) return false;
        
        HashMap<Character,Integer>map = new HashMap<>();
        
        int psize = s1.length();
        int size = s2.length();
        
        for(int i=0;i<psize;i++){
            char ch = s1.charAt(i); 
            map.put(ch,map.getOrDefault(ch,0)+1);
        }
        
        int begin = 0, end = 0;
        
        int counter = map.size(); //taking map size because string can also have duplicates.
        
        while(end<size){
            char c = s2.charAt(end);
            if(map.containsKey(c)){
                map.put(c,map.get(c)-1);
                if(map.get(c)==0)counter--;
            }
            
            end++;
            
            while(counter==0){
                char temp = s2.charAt(begin);
                if(map.containsKey(temp)){
                    map.put(temp,map.get(temp)+1);
                    if(map.get(temp)>0)counter++;
                }
                
                if(end-begin == psize){
                    return true;
                }
                begin++;
            } 
        }
        
        return false;
    }
-------------------------------------------------------------------------------------
29. Subset II (Leetcode 90)
->
public List<List<Integer>> subsetsWithDup(int[] nums) {
      List<List<Integer>>ans=new ArrayList<>();        
        Arrays.sort(nums);
        
        powerSet(nums,0,new ArrayList<>(),ans);
        return ans;
    }
    public void powerSet(int[]nums,int idx,List<Integer>list,List<List<Integer>>ans){
        ans.add(new ArrayList<>(list));

        for(int i=idx;i<nums.length;i++){
            if(i!=idx && nums[i]==nums[i-1]) // for i = idx (first item of that subset)
                continue; 
             list.add(nums[i]);
            powerSet(nums,i+1,list,ans);
             list.remove(list.size()-1);
        }
        return;
    }
-------------------------------------------------------------------------------------
30. Burst Ballons 
  // we have n! ways to burst the ballons 
    // for eg) {2 3 5} -> a) 2 3 5 , b) 2 5 3 , c) 3 5 2 , d) 3 2 5 , e) 5 2 3 , f) 5 3 2    => 3! = 6 ways
 /*   
    Intuition -> https://www.youtube.com/watch?v=YzvF8CqPafI
    
    1. We know that if only one ballon remains then the coins which we will get is  1*nums[i]*1;
    2. So we can say that we already know the ans for last ballon which get bursted.
    3. Hence we say that for each i we are considering that all the ballons in its left and right already get bursted means 
    it is the last ballon to get burst then what will be the max coins which we can collect.
    4. We are saying this because we know that there is no relation with the already bursted ballons.
   
   dp[i][j] stores that we you burst a range (i,j){ in a definite order } out of the whole array leaving 
   other left and right elements as it is then what is the max coins you can collect.
   
   [a1,a2,a3,a4,(ai,ai1,ai2,ai3,....aj),an-2,an-1,an] <- so here suppose you have ai->aj range.
   Now for this we say that we are bursting 'ai' and (ai1->aj) is already bursted so coins we will get is (a4*ai*an-2);
   when we burst 'ai3', we consider that it is the last ballon to be bursted in the range (ai->aj)<- already bursted.
   so in this case we get coins =>(a4*ai3*an-2);   
 */   

public int maxCoins(int[] nums) {
        return BurstBallons(nums,0,nums.length-1,new int[nums.length][nums.length]);
    }
    public int BurstBallons(int[]nums,int start,int end,int[][]dp){
        if(start>end) return 0;
        
        if(dp[start][end]>0) return dp[start][end];
        
        int ans = 0;
        for(int i=start;i<=end;i++){
            int left=(start>0)?nums[start-1]:1;
            int right=(end<nums.length-1)?nums[end+1]:1;
            
            int sum=left*nums[i]*right + BurstBallons(nums,start,i-1,dp) + BurstBallons(nums,i+1,end,dp);
            ans=Math.max(sum,ans);
        }
        
        return dp[start][end] = ans;    
    }
-------------------------------------------------------------------------------------
31. Rotate Array (in place)
-> Complexity should be O(N).
   
The basic idea is that, for example, nums = [1,2,3,4,5,6,7] and k = 3, first we reverse [1,2,3,4], it becomes[4,3,2,1]; then we reverse[5,6,7], it becomes[7,6,5], finally we reverse the array as a whole, it becomes[4,3,2,1,7,6,5] ---> [5,6,7,1,2,3,4].

Reverse is done by using two pointers, one point at the head and the other point at the tail, after switch these two, these two pointers move one position towards the middle.
    
    public void rotate(int[] nums, int k) {
        
        int n = nums.length;
        
        k = k % n;
        
       reverse(nums,0,n-k-1);
       reverse(nums,n-k,n-1);
       reverse(nums,0,n-1); 
    }
    public void reverse(int[]nums,int l,int h){
        while(l<h){
            
            int temp = nums[l];
            nums[l]=nums[h];
            nums[h]=temp;

            l++;
            h--;
        }
    }
-------------------------------------------------------------------------------------
32. Closest Leaf to a given node in a binary tree
O(N)-S(H)

 public static int INF = 1000000;

    // Function that returns the distance of the closest leaf in the sub tree.
    public static int closestLeafNodeInSubtree(BinaryTreeNode<Integer> root) {
        if (root == null) {
            return INF;
        }

        if (root.left == null && root.right == null){
            // Node is a leaf node.
            return 0;
        }

        int distLeft = closestLeafNodeInSubtree(root.left);
        int distRight = closestLeafNodeInSubtree(root.right);

        return (1 + Math.min(distLeft, distRight));
    }

    private static int ans;

    // Helper function to calculate the closest leaf distance of the node.
    public static int findClosestLeafNodeDistanceHelper(BinaryTreeNode<Integer> root, int x){
        if (root == null){
            return INF;
        }

        // If the required node is found, calculate the distance of the closest leaf node.
        if (root.data == x){
            ans = closestLeafNodeInSubtree(root);
            return 0;
        }

        int distLeft = findClosestLeafNodeDistanceHelper(root.left, x);
        if (distLeft != INF) {
            // Node X is present in left subtree.
            int dist = (distLeft + 2) + closestLeafNodeInSubtree(root.right);
            ans = Math.min(ans, dist);
            return (1 + distLeft);
        }

        int distRight = findClosestLeafNodeDistanceHelper(root.right, x);
        if (distRight != INF) {
            // Node X is present in right subtree.
            int dist = (distRight + 2) + closestLeafNodeInSubtree(root.left);
            ans = Math.min(ans, dist);
            return (1 + distRight);
        }

        // Node X not found in the subtree.
        return INF;
    }

-------------------------------------------------------------------------------------
33. Split BST

public TreeNode[] splitBST(TreeNode root, int V) {
        if (root == null)
            return new TreeNode[]{null, null};
        if (root.val == V) {
            TreeNode right = root.right;
            root.right = null;
            return new TreeNode[]{root, right};
        }
        else if (root.val > V) {
            TreeNode[] nodes = splitBST(root.left, V);
            TreeNode left = nodes[0];
            TreeNode right = nodes[1];
            root.left = right;
            return new TreeNode[]{left,root};
        } else {
            TreeNode[] nodes = splitBST(root.right, V);
            TreeNode left = nodes[0];
            TreeNode right = nodes[1];
            root.right=left;
            return new TreeNode[]{root, right};
        }
    }
-------------------------------------------------------------------------------------
34. Given a binary search tree and a range [L, R], delete all elements which are not in the range.
O(N)
 private static Node removeOutsideRange(Node root,
                                           int min, int max)
    {
        // BASE CASE
        if(root == null)
        {
            return null;
        }
         
        // FIRST FIX THE LEFT AND
        // RIGHT SUBTREE OF ROOT
        root.left = removeOutsideRange(root.left,
                                       min, max);
        root.right = removeOutsideRange(root.right,
                                        min, max);
         
        // NOW FIX THE ROOT. THERE ARE
        // TWO POSSIBLE CASES FOR THE ROOT
        // 1. a) Root's key is smaller than
        // min value(root is not in range)
        if(root.key < min)
        {
            Node rchild = root.right;
            root = null;
            return rchild;
        }
         
        // 1. b) Root's key is greater than
        // max value (Root is not in range)
        if(root.key > max)
        {
            Node lchild = root.left;
            root = null;
            return lchild;
        }
         
        // 2. Root in range
        return root;
    }
-------------------------------------------------------------------------------------
35. Kth Ancestor of a binary tree

-> https://www.youtube.com/watch?v=PE-kQVZxvWA&t=1895s

  // O(logn) <- for query S(nlogn)
    
   
  int[][] jump;
    int maxPow;

    public TreeAncestor(int n, int[] parent) {
        // log_base_2(n)
        maxPow = (int) (Math.log(n) / Math.log(2)) + 1;
        jump = new int[maxPow][n];
        jump[0] = parent;
        for (int p = 1; p < maxPow; p++) {
            for (int j = 0; j < n; j++) {
                int pre = jump[p - 1][j];
                jump[p][j] = pre == -1 ? -1 : jump[p - 1][pre];
            }
        }
    }

    public int getKthAncestor(int node, int k) {
        int maxPow = this.maxPow;
        while (k > 0 && node > -1) {
            if (k >= 1 << maxPow) {
                node = jump[maxPow][node];
                k -= 1 << maxPow;
            } else
                maxPow -= 1;
        }
        return node;
    }
-------------------------------------------------------------------------------------
36. A tree is considered special if the sums of all the nodes at each level are in an Arithmetic Progression (AP).
Given the root note of a binary tree. Return an array representing the minimum number that can be added at each level to make that tree special.

We need to solve it in O(N) time and O(1) space.
Bonus : We can't store the sums at each level.

Example -
Input 1:

          3
        /   \
       2     7
        \
	 15

Output: [0, 0, 0] since the sums were already in AP. {3, 9, 15}

Input 2:

          1
        /   \
      11     5
      / \     \
     2   15    10
     \
      50

Output: [0, 0, 4, -4].


Approach:

 	  1 - 1
        /   \
      11     5 - 16
      / \     \ 
      2  15    10 - 27
       \
        50           -50

1. At each level i (total levels here l = 4) am storing the sum, and also through complete traversal i am finding the total sum of the Tree, Here it is 94

2. Now, generalizing the term as An = a + (n-1)d => a = An - (n-1)d.

3. Sum formula  = level/2 * (2a + (level - 1)d) =>

4. Converted Sum formula  => level/2 * (2an + (level - 2*currlevel + 1)d) 

5. At each level we just equate the total sum leaving d as it is and then find the value of d (in case of decimal then two values will be there floor and ceil)for both the values find the sum which is the closest to the actual total sum take that as d in this way we get the d which gives closest sum.

6. So minimum diff between the sum which we get through formula vs the total sum, the d which gives the min that would be our final d

7. At last we have a, d, currlevel just find An th term (equals to sum of that level) and see the actual sum which is present in the tree then take the difference.

Exact sum = [1,16,27,50] , our sum through our a and d = [1,15,31,46], so the output will be [0,0,4,-4].
 
Total Sum =94
Each level sum = [1,16,27,50].
 
All level calculations in order to find the perfect d.
Level 1 =  2*( 2 + 3*d) = 4+ 6d  = 94
			d = 14 ~ 88
			d = 15 ~ 94
Level 2 = 2*(32 + d) = 94
		d = 15 ~ 94 

Level 3 = 2*(54 - d) = 94
     		d = 3 ~102
		d = 4 ~100

Level 4 = 2(100 - 3d) = 94
	d = 17 ~ 98
	d = 18 ~ 92


Through all the levels i got my d as 15 which gives the closest (here exact) sum of the AP.
-------------------------------------------------------------------------------------
38. Dungeon Game (LeetCode 174)

class Solution {
    // For this approach refer the below discuss article and dry run the code (for 2x2 matrix) for a clear understanding.
  //  https://leetcode.com/problems/dungeon-game/discuss/745340/post-Dedicated-to-beginners-of-DP-or-have-no-clue-how-to-start
    
    public int calculateMinimumHP(int[][] dungeon) {
        int m = dungeon.length;
        int n = dungeon[0].length;
        
        int[][]dp = new int[m][n];
        
        for(int[]dpp:dp){
            Arrays.fill(dpp,-1);
        }
        
        // 1 is the min energy that must be given because if at any cell king energy becomes <=0 then he dies.
        return  minEnergy(dungeon,0,0,m,n,dp);
    }
    
    public int minEnergy(int[][]cell,int i,int j, int m,int n,int[][]dp){
        if(i==m || j==n)return 100000000;
        
        if(i==m-1 && j==n-1){
            return (cell[i][j]>0)?1:-(cell[i][j])+1;
        }
        
        if(dp[i][j]!=-1)return dp[i][j];
        
        int minEnergyRequired = 0;
        
        int goRight = minEnergy(cell,i,j+1,m,n,dp);
        int goDown = minEnergy(cell,i+1,j,m,n,dp);
        
        minEnergyRequired = Math.min(goRight,goDown) - cell[i][j];
        
        return (dp[i][j] = (minEnergyRequired<=0)?1:minEnergyRequired);
    }
}
-------------------------------------------------------------------------------------
39. Simplify Path (LeetCode 71)
-> Stack based approach
 public String simplifyPath(String path) {
    
        Deque<String>deq = new ArrayDeque<>();
        Set<String> skip = new HashSet<>(Arrays.asList("",".",".."));
        
        for(String str: path.split("/")){
           if(!deq.isEmpty() && str.equals("..")){
               deq.poll();
           }else if(!skip.contains(str)){
               deq.push(str);
           } 
        }
        
        if(deq.isEmpty())return "/";
        
        StringBuilder sb = new StringBuilder();
        while(!deq.isEmpty()){
            sb.append("/").append(deq.pollLast());
        }
        
        return sb.toString();
    }
-------------------------------------------------------------------------------------
40. Maximum Side length of a Square with sum less than or equal to threshold. (leetcode 1292)

M1) O(m*n)

 public int maxSideLength(int[][] mat, int threshold) {
      	// print both the arrays (sum & mat) and also dry run to understand how this prefix sum is
		// being made.
		// sum[i][j] represents the sum of all the elements which makes the rectangle
		// having coordinates -> (0,0),(0,j),(i,0),(i,j);

		int m = mat.length;
		int n = mat[0].length;
		int[][] sum = new int[m + 1][n + 1];

		int res = 0;
		int len = 1;

		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				 // -sum[i-1][j-1] to remove the overlapping part.
				sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + mat[i - 1][j - 1];

		// +sum[i-len][j-len] to add the part which got deleted two times due to overlapping;
		if (i >= len && j >= len && sum[i][j] - sum[i - len][j] - sum[i][j - len] 
						+ sum[i - len][j - len] <= threshold){  
					res = len;
					len++;
				}

			}
		}
		return res;
   	 }

M2) O(m*n*log(min(m,n)))
-> Binary Search and prefix sum.
-> Firstly just like above make a prefix array but not check in the that loop itself.
-> for that take lo = 0, hi = min(m,n) and then apply binary search and in the black box of binary search
check for the condition which has been checked in the above approach in the latter part of the loop.
-> if possible then lo=mid+1 else hi=mid-1;

-------------------------------------------------------------------------------------
41. Avoid Flood in the City (Leetcode 1488)
->
    // Read this approach if any doubt- >https://leetcode.com/problems/avoid-flood-in-the-city/discuss/716206/Java-Well-explained-O(n2)
    
    public int[] avoidFlood(int[] rains) {
       //this map will store the rain corresponds to the prev last index of its occurence
        HashMap<Integer,Integer>map = new HashMap<>();
       
//Dont try to find the zero in treeset as floor(i) for the curr rain which has been previously visited, in this way you
// are ignoring this case -> [0,1,1] here when 1 comes for the first time you just put it in the set and second time when you first 
// when you perform thr function for it to find the prev zero that won't work as it is not a valid case. 
// Instead find the location ahead of the previous occurence of the current rain in the zero treeset as described in the below soln.
       
       
        //this stores the location of zeros in sorted order
        TreeSet<Integer>zeros = new TreeSet<>();
        int n = rains.length;
        int[]res = new int[n];
        
        for(int i=0;i<n;i++){
            if(rains[i]==0){
                zeros.add(i);
                res[i]=1;  //in case this zero could not used.
            }else{
                if(map.containsKey(rains[i])){
                    // find the location of zero that can be used to empty rains[i]
                    Integer next = zeros.ceiling(map.get(rains[i]));
                    //if next is null so you cant dry the lake means there will be flood.
                    if(next==null){
                        return new int[0];
                    }
                    zeros.remove(next); //since this 0 has been used now.
                    res[next]=rains[i];
                }
                res[i]=-1; //according to the problem
                map.put(rains[i],i);
            }
        }
        return res;
    } 
-------------------------------------------------------------------------------------
42. Distinct Subsequences (Leetcode 115)
->  public int numDistinct(String s, String t) {
        int m = s.length();
        int n = t.length();
        
        int[][]dp = new int[m][n];
        for(int[]dpp:dp){
            Arrays.fill(dpp,-1);
        }
        return distinctSubsequences(s,t,0,0,m,n,dp);
    }
    public int distinctSubsequences(String s,String t, int i,int j,int m,int n,int[][]dp){
        if(j==n){
            return 1;
        }
        if(i==m){
            if(j==n){
                return 1;
            }
            return 0;
        }
        
        if(dp[i][j]!=-1){
            return dp[i][j];
        }        
        
        char c1 = s.charAt(i);
        char c2 = t.charAt(j);
        
        int op1=0,op2=0,op3=0;
        if(c1==c2){
            op1 = distinctSubsequences(s,t,i+1,j+1,m,n,dp);
            op2 = distinctSubsequences(s,t,i+1,j,m,n,dp);
        }else{
            op3 = distinctSubsequences(s,t,i+1,j,m,n,dp);
        }
        return dp[i][j] = op1+op2+op3;
    }
-------------------------------------------------------------------------------------
43. Minimum Difference in sums after removal of elements (Leetcode 2163)
-> Basically the goal is the get the min sum of n/3 elements for the first part and max sum of n/3 elements in the
second part to minimize the difference and the ans will be the min difference of elements lies between (n/3->2*n/3)

public long minimumDifference(int[] nums) {
        int n=nums.length;  //length of nums
        int len3=n/3;       // 1/3 length
        long res=Long.MAX_VALUE; // final result;
        //Try to make first part as min as possible;
        //first[m] store the value, the min value of the size=len3, from[0,1,..., m];  
        long[] first=new long[n]; 
        //Try to make second part as max as possible;
        //second[m] store the value, the max value of the size=len3, from[m,...,n-1];  
        long[] second=new long[n];
        
//--------------------for first part compute -------------------------------------
        //Build max heap for first part;
        PriorityQueue<Integer> max=new PriorityQueue<Integer>(Comparator.reverseOrder());
        
        long sum=0;

        // Initialize with the first 1/3 n part.
        for(int i=0;i<len3;i++){
            sum+=nums[i];
            max.add(nums[i]);
        }
        //For the second part between 1/3 ~ 2/3. When we move to next index.
        //we keep the sum as total 1/3n size: each time poll the max one and add the new one;
        //And we keep tracking the exchange by long[] first;
        //
        for(int i=len3;i<=2*len3;i++){
            first[i]=sum;     //add sum from  1/3
            max.add(nums[i]); //put new one in queue;
            sum+=nums[i];     //sum + new one;
            sum-=max.poll();  //sum - max one;
        }
//--------------------for second part compute -----------------------
        sum=0;
        //Build min heap for first part;
        PriorityQueue<Integer> min=new PriorityQueue<Integer>();
        // Initialize with the last 1/3 n part.
        for(int i=0;i<len3;i++){
            sum+=nums[n-1-i];
            min.add(nums[n-1-i]);
        }
        //For the second part between 2/3~1/3 When we move to next index:
        // we keep update the sum with(+ new element, - min element), and update second;
        for(int i=len3;i<=2*len3;i++){
            second[n-i]=sum;
            min.add(nums[n-1-i]);
            sum+=nums[n-1-i];
            sum-=min.poll();
        }
//-----------------compute the final result------------

        //find the max value in second part [ i,..., n-1];
        //find the min value in first part [0,....,i];
        // find the result;
        for(int i=len3;i<=2*len3;i++){
            res=Math.min(res,first[i]-second[i]);
        }
        
        return res;
    }
-------------------------------------------------------------------------------------
44. Replace the substring for balanced String (leetcode 1234)
Approach Reference -> https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/409017/JAVA-Sliding-Window-Solution-with-Explanation

So Basically we are storing the freq of each character Q,W,E,R and then applying sliding window.
How Sliding window? -> String will be balanced when each of the above characters have exactly n/4 freq.
-> So we just move our right pointer and when we move, we just check that whether the each (freq<=n/4).
-> if yes then it means that we are at our valid substring we can make our ans. 
-> But if not satisfied then keep on decrementing. 
-> let the string be "WQWRWEQW" the first satisfied condition occurs when we have WQW in the window. here it can be replaced by RQE or its any permutation.
-> Since this is valid substring and we can make our ans as min(ans,j-i+1).
-> the window again shrinked by incrementing the freq from left indices.

-> By this approach the problem boils down to minimum length substring containing a certain number of each character.  and the certain number is (all character having freq <=n/4)

    // It is a tricky question just dry run to understand it better for the case "WQWRWEQW"-> 3 is the ans.
    public int balancedString(String s) {        
        
        int[] count = new int[128];
        int n = s.length(), res = n, left = 0, k = n / 4;
        for (int j = 0; j < n; j++) {
            count[s.charAt(j)]++;
        }
        for (int right = 0; right < n; right++) {
            count[s.charAt(right)]--;
            while (left < n && count['Q'] <= k && count['W'] <= k && count['E'] <= k && count['R'] <= k) {
                res = Math.min(res, right - left + 1);
                count[s.charAt(left++)]++;
            }
        }
        return res;
    }
-------------------------------------------------------------------------------------
45. Longest Substring without Repeating Characters (Leetcode 3)
-> Sliding window approach

public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        
        int i=0,j=0;
        Set<Character>set = new HashSet<>();
        
        int res=0;
        
        while(j<n){
            char ch = s.charAt(j);
            if(!set.contains(ch)){
                set.add(ch);
                res = Math.max(res,j-i+1);
                j++;
            }else{
                while(set.contains(ch) && i<j){
                    set.remove(s.charAt(i));
                    i++;
                }
            }
        }
        return res;
    }
-------------------------------------------------------------------------------------
46. Longest Continuous Subarray with Absolute Diff less then Equal to Limit
-> Basically "Absolute difference between min and max elements of subarray"

-> Why are we shrinking when we get difference greater than limit?
=> Because the max Deque now contains max element in ith-jth window now if any element comes if smaller then the difference will not decrease(means the peekFirst will not change) but if bigger then difference will increase.
Similarly for the min Deque the peekFirst of this can also be changed when the curr element is even smaller than the peekFirst & if it happens then the min becomes more min resulting the difference will increase. 
That's why we are shrinking.


 public int longestSubarray(int[] nums, int limit) {
        int n = nums.length;
        int i =0,j=0;
        
        Deque<Integer>max = new LinkedList<>();
        Deque<Integer>min = new LinkedList<>();

        int res=0;
        
        while(j<n){
            
            while(!max.isEmpty() && nums[j]>max.peekLast()){
                max.pollLast();
            }
            while(!min.isEmpty() && nums[j]<min.peekLast()){
                min.pollLast();
            }
            
            min.addLast(nums[j]);
            max.addLast(nums[j]);
            
            while(max.peekFirst()-min.peekFirst()>limit){
              if(max.peekFirst()==nums[i])max.pollFirst();
              if(min.peekFirst()==nums[i])min.pollFirst();
              i++;
            }
            res = Math.max(res,j-i+1);            
            j++;
        }
        
        return res;
    }
-------------------------------------------------------------------------------------
47. Frequency of the most frequent element (Leetcode-1838)

M1) Sliding window approach 
Sort the input array.

the key is to find out the valid condition:
k + sum >= size * max  <- just take a dry run to understand this part.
which is
k + sum >= (j - i + 1) * A[j]

public int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);
        
        int n = nums.length;
        int i=0,j=0;
        int res = 0 ;
        long sum = 0;
                
        while(j<n){
            sum+=nums[j];
            while(sum+k < (j-i+1)*nums[j]){
                sum-=nums[i];
                i++;
            }
            res = Math.max(res,j-i+1);
            j++;
        }
        return res;
    }


M3) Binary Search <- little bit complex
-> https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175181/JavaPython-Prefix-Sum-and-Binary-Search-O(NlogN)
-------------------------------------------------------------------------------------
48. Reduce array size to the half (Leetcode-1338)

M1) Use priorityQueue and map, and remove all the occurence of the most freq and then pop from priorityQueue and do this for all until the count becomes greater than equal to array size/2.
the elements we be added int the set or we can maintain another count.


M2) Using Kind of Bucket

public int minSetSize(int[] arr) {
	Map<Integer, Integer> map = new HashMap<>();
	ArrayList<Integer>[] list = new ArrayList[arr.length + 1];
	
	for (int num : arr) {
		map.put(num, map.getOrDefault(num, 0) + 1);
	}

	for (int num : map.keySet()) {
		int count = map.get(num);
		if (list[count] == null) {
			list[count] = new ArrayList<Integer>();
		}
		list[count].add(num);  
	}
	
	int steps = 0, res = 0;
	for (int i = arr.length; i > 0; i--) {
		List<Integer> cur = list[i];
		if (cur == null || cur.size() == 0) continue;
		for (int num : cur) {
			steps += i;	// at this freq there can be multiple elements that's why adding i
			res++;
			if (steps >= arr.length / 2)
				return res;
		}
	}
	return arr.length;
}
-------------------------------------------------------------------------------------
49.
-------------------------------------------------------------------------------------
50.
-------------------------------------------------------------------------------------
51.
-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------

  
