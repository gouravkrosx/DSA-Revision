			                        			Some Extra Questions

------------------------------------------------------------------------------------
1. Tower of Hanoi ->https://www.youtube.com/watch?v=QDBrZFROuA0
-> Make the recursion Tree and do the dry run , and do inorder traversal 
public static void toh(int n, int t1id, int t2id, int t3id){
        if(n==0){
            return;
        }
        //(*) ->Means following all instructions of tower of hanoi
        toh(n-1,t1id,t3id,t2id); //will print the instructions to move n-1 disks from t1 to t3 using t2(*)
        System.out.println(n+"["+t1id+" -> "+t2id+"]");
        toh(n-1,t3id,t2id,t1id);
    }
-------------------------------------------------------------------------------------
2. Do All variations of buy and sell stock
-------------------------------------------------------------------------------------
3. Permutations (leetcode 46)
->Time complexity->(n!*n)
->Space complexity->(2n)

Using extra space->
 public void solve( List<List<Integer>>ans,List<Integer>ds,boolean[]freq,int[]nums){
        if(ds.size()==nums.length)
        {
            ans.add(new ArrayList<>(ds));
            return;
        }
        
        for(int i=0;i<nums.length;i++){
            if(!freq[i]){
                freq[i]=true;
                ds.add(nums[i]);
                solve(ans,ds,freq,nums);
                ds.remove(ds.size()-1);
                freq[i]=false;
            }
        }
    }
Space optimised->
 public void solve(List<List<Integer>>ans,int idx,int[]nums){
    
        if(idx==nums.length){
            //copy the altered array.
            List<Integer>ds=new ArrayList<>();
            for(int i=0;i<nums.length;i++){
                ds.add(nums[i]);
            }
            ans.add(new ArrayList<>(ds));
            return;
        }
        //swap every index with every other ahead index
        for(int i=idx;i<nums.length;i++){
            swap(i,idx,nums);
            solve(ans,idx+1,nums);
            swap(i,idx,nums);
        }    
    }


-------------------------------------------------------------------------------------
4. Subarray Product less than K (leetcode 713)

-------------------------------------------------------------------------------------
5. Contiguous Array ( Leetcode 525 )

-------------------------------------------------------------------------------------
6. Largest Subarray with sum 0 
 public static int LargestSubarrayWithSum0(int[]arr,int n){
        HashMap<Integer,Integer>map=new HashMap<>();
        int max=0;
        int sum=0;
        
        for(int i=0;i<arr.length;i++){
            sum+=arr[i];
            if(sum==0){
                max=i+1;
            }else{
                if(map.get(sum)!=null){
                    max=Math.max(max,i-map.get(sum));
                }else{
                    map.put(sum,i);
                }
            }
        }
        return max;
    }

-------------------------------------------------------------------------------------
7. largest Subarray with sum no larger than k

private int maxSumSubArray(int[] a , int k){

    int max = Integer.MIN_VALUE;
    int preSum = 0;
    TreeSet<Integer> ts = new TreeSet();
    ts.add(0);

    for(int i=0;i<a.length;i++){
        preSum += a[i];
        Integer gap = ts.ceiling(preSum - k);
        if(gap != null) max = Math.max(max, preSum - gap);
        ts.add(preSum);
    }
    return max;
}
-------------------------------------------------------------------------------------
8. Subarray Sum Equals K (pepcoding)
-------------------------------------------------------------------------------------
9. Word Break (pepcoding)->https://www.youtube.com/watch?v=2NaaM_z_Jig

-------------------------------------------------------------------------------------
10. Minimum Size Subarray Sum (Leetcode 209)
-------------------------------------------------------------------------------------
11. Predict the winner
-------------------------------------------------------------------------------------
12. Min jump game 2 Leetcode 
-------------------------------------------------------------------------------------
13. Longest Arithmetic Subsequence of Given Difference (Leetcode 1218)
-------------------------------------------------------------------------------------
14. Longest Consecutive Sequence (Leetcode 28)
-------------------------------------------------------------------------------------
15. All Paths From Source to Target (Leetcode 797)
-------------------------------------------------------------------------------------
16. Path In Zigzag Labelled Binary Tree (Leetcode 1104.)
-------------------------------------------------------------------------------------
17. Validate Binary Tree Nodes (Leetcode 1361)
-------------------------------------------------------------------------------------
18. Biggest cycle in Directed Graph.
-------------------------------------------------------------------------------------
19. Ford-Fulkerson Algorithm for Maximum Flow Problem
	
-------------------------------------------------------------------------------------
20. Longest path in an undirected tree.
-> Apply 2 Bfs two times 
1. choose any node apply bfs to find the longest distance let this node be y.
2. Now from y apply bfs to find the longest path. which is the diamter of the tree.
-------------------------------------------------------------------------------------
21. Maximum Binary Tree (Leetcode-654)
-------------------------------------------------------------------------------------
22. Cycle sort
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------
